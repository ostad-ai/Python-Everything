# Python-Everything

1. Lists: Introduction.
2. Lists: Example, computing Khayyam-Pascal's triangle.
3. Lists: Copying.
4. Exercise: Solving quadratic equation.
5. Stacks are implemented by lists. An example to reverse a list with stack is also included.
6. strings in Python: Introduction.
7. Emojis in Python with some examples.
8. Working with polynomials represented by lists in Python. Here, we implement, from scratch, addition and multiplication of two polynomials.
9. Removing punctuations from a given text. Here, we also download a text-file from the Internet using *request* of *urllib*.
10. Dictionaries in Python: Introduction, from creating to accessing, updating, deleting items, and copying.
11. Exercise: Converting variable names to strings, and vice versa, using function *globals()*.
12. Frequency counting of words (or letters) of a given text. Also, a real text is downloaded from the Internet and the functions are tested with it. We use the *get* function of dictionaries in Python. Moreover, we plot the frequencies with  *bar* of *matplotlib*.
13. Sets in Python: Introduction, which includes set creation and initialization, acessing elements, set operations, copying and clearing, and also a hint on *frozensets*. Moreover, an example is given about *Jaccard distance*.
14. Pickle module, introduction: We use *dump* and *load* to save Python object into a byte stream and vice versa.
15. Classes in Python, introdcution: Class definition and how to get instances from it are mentioned. Also, methods are reviewed. The difference between class variables versus instance variables is expressed. Examples are provided to help the explanation.
16. Three different types of methods (functions) in Python are reviewed: instance method, class method, and static method. We use decorators: @classmethod and @staticmethod, for building class methods or static methods.
17. Exercise: Computing the possible outcomes of a ranking event for the FIFA World Cup 2022, knowing the semi-final matches, using *itertools.permutations*.
18. Logging module in Python, introduction: Using functions of logging module, we can display logging messages to the console or save them to a file. Here, these functions such as debug(), info(), warning(), error(), and critical() are mentioned.
19. Unittest module in Python, introduction: We can use unittest module to design unit tests or integration tests. For unit tests, we define a class, which inherits *unittest.TestCase*. Here, we define a factorial function, and then we define test units for this factorial to reveal bugs in our factorial.
20. Exercise: Factorial for non-negative integer and float numbers with *gamma* and *factorial* function of *math module*.
21. SQLite3 module, introduction: We can use *sqlite3* module in Python for creating and accessing databases without the need to have a separate server. Here, we use basic commands of **SQL** for such purposes. For example, for creating and manipulating tables in our database.
22. Operator overloading in Python: Using built-in operators, it is possible to change their behaviors via implementing their relevant special methods in a custom class definition. Here, we implement operator == for almost-equal. Also, we implement operator + for vector summation. 
23. Lambda expressions: We may use lambda keyword to define anonymous functions. Here, we define the syntax for lambda expressions, and then we bring some applications.
24. Magic methods, __getitem__ and __setitem__: We review getitem and setitem methods that may be used for **indexing** and **assignment** on instances of a class, respectively.  
25. Iterators and iterables: We use iterators to iterate over iterables. This section reviews both of them. Lists, sets, tuples, and dictionaries are examples of iterables.
26. Callable objects: We can make a class callable by defining a method in the class named **--class--**. This way, any instance of the class can be called like a function.
27. List comprehension: We may use list comprehension to create lists from another lists or any iterables in  a concise way. A list comprehension may include for-loops and if-clauses.
28. Functions: We will have a closer look at functions. Calling  functions by-reference or by-value are mentioned. Functions may have a variable number of arguments. Also, functions may have a variable number of keyword arguments. Some example are provided for clarification.
29. Generator functions and expressions: By using keyword **yield** in a function, instead of  keyword **return**, we get a generator function. We see some examples of how to use generator functions. Also, we introduce *generator expressions* and see their difference with list comprehensions.
30. Handling files: We create, read, write files (text or binary) with **open**. We can also append data to an existing file. Generally, in this post, we mention how to deal with files in Python. We talk shortly about encoding and decoding from character string to byte string and vice versa. Moreove, we can check if a file exists or not. 
31. Python Exercise: Compute the probability that a set of integers less than or equal to some certain numbers are all divisible by a common divisor.
32. Enumeration in Python: We can use symbolic names in Python using enumerations. For this purpose, we employ module *enum* of the Python standard library. Enumeration is reviewed via some examples.
33. Python Exercise: Population growth is reviewed using Python.